#include <bits/stdc++.h>
using namespace std;

#define MAXW 2    // the max width for trie ('0' and '1' so it's 2).
#define MAXN 64   // the max n for input and also the max length of code.
#define MAXM 1001 // the max m for input.

/*
 * -------------------------------- Main idea about our algorithm --------------------------------
 * First of all, we should check that no code is a prefix of another.
 * Here I use trie to optimize the prefix-check.
 * Secondly, we should check that if their submission cost more than cost by huffman's algorithm.
 * As it mentions that The optimal solution is not necessarily generated by Huffman algorithm, so just cost-equal is enough.
 * I think the time complexity reduce to O(m*nlog(n))
*/

// struct of trie declaration.
struct trie
{
    bool is_wordend = false; // is this node is the last word.
    int num = 0;             // the number of words after this prefix.
    struct trie *next[MAXW]; // the next node (represented by 0 and 1).
};
// create a node of trie.
trie *Create_node()
{
    trie *node = new trie();
    for (int i = 0; i < MAXW; i++)
        node->next[i] = NULL;
    return node;
}
// insert a string to the tree and return judgement on if some word is a prefix of another.
bool Insert(trie *root, char *s)
{
    bool f = true;  // judge if some word is a prefix of another.
    trie *node = root;
    for (int i = 0; i < strlen(s); i++)
    {
        int index = s[i] - '0'; // judge 0 or 1
        if (node->next[index] == NULL)
            node->next[index] = Create_node();
        node = node->next[index];
        node->num++;
        // judge if it's the end of a word.
        if (i == strlen(s) - 1)
            node->is_wordend = true;
        // if some word is a prefix of another.
        if (node->num > 1 && node->is_wordend)
        {
            f = false;
            break;
        }
    }
    return f;
}

map<char, int> char_freq;                          // store the charecter and map its frequency.
priority_queue<int, vector<int>, greater<int>> pq; // priority queue to use huffman's algorithm.

// compare function to sort the string in m students' input in ascending order by size.
bool cmp(pair<char, string> x, pair<char, string> y)
{
    return x.second.size() < y.second.size();
}
// calculate the cost by huffman's algorithm by simulating the priority queue
// and we can add it to cost level by level.
int Huffman_cost()
{
    int cost = 0;
    while (!pq.empty())
    {
        int tl = pq.top();
        pq.pop();
        if (pq.empty())
            break;
        int tr = pq.top();
        pq.pop();
        cost += tl + tr;
        pq.push(tl + tr);
    }
    return cost;
}

int main()
{
    int n, m;        // store the input n and m.
    bool flag[MAXM]; // store if the student's submission is correct.
    int cost = 0;    // store the cost by huffman algorithm.
    cin >> n;
    // deal with n character and map them.
    for (int i = 0; i < n; i++)
    {
        int t;
        char c;
        cin >> c >> t;
        char_freq.insert(pair<char, int>(c, t));
        pq.push(t);
    }
    cost = Huffman_cost();
    // initialize the flag of m students' submission as true.
    cin >> m;
    // check the submissions' correctness.
    for (int i = 0; i < m; i++)
    {
        flag[i] = true;
        int temp_cost = 0;
        trie *root = Create_node();
        for (int j = 0; j < n; j++)
        {
            bool f = true;
            char c, s[MAXN];
            cin >> c >> s;
            // if flag[i] is false, then we can say the submission is false and we don't need to insert to save times.
            if (flag[i])
                f = Insert(root, s);
            if (!f)
                flag[i] = false;
            // calculate the cost of word.
            temp_cost += char_freq[c] * strlen(s);
        }
        // if some word is a prefix of another.
        if (!flag[i])
            continue;
        // if cost more than a huffman cost.
        if (temp_cost > cost)
        {
            flag[i] = false;
            continue;
        }
    }
    // output the check result.
    for (int i = 0; i < m; i++)
    {
        if (flag[i])
            printf("Yes\n");
        else
            printf("No\n");
    }
    return 0;
}